import numpy as np
import pandas as pd
import json


class TrafficServer:
    """Emulates the data plane of a communication system

    TrafficServer can provide certain service for the traffic generated by a TrafficEmulator. It is essentially the
    data-plane of a communication system, and decide service under the instruction of the control-plane - Controller.

    To use it, first feed it with some traffic and wait it to update its internal state, then make observation from it
    and propagate it to the controller, who will issue specific control commands. Using these control commands, one can
    get services for the traffic fed, and also receive a operational cost at the same time.

    Note all functions are not necessarily fully controlled by the controller, and the TrafficServer may have some
    sovereign over miscellaneous functions and only leave the most important parts for the Controller to decide. To this
    regard, the TrafficServer can have some hidden state that is not observable by the controller.

    A important implementation feature in our current project is to give TrafficServer the ability to sleep and queue
    requests. These operational states are reflected in both the service generated and the cost emitted.
    """
    def __init__(self, verbose=0):
        self.epoch = 0
        self.q = pd.DataFrame(columns=['sessionID', 'uid', 'arriveTime_epoch', 'bytesSent_per_request_per_domain'])
        self.verbose = verbose      # verbosity level

    # Public Methods
    def observe(self, traffic_df):
        """Compile observation
        traffic_observation = self.observe_traffic_(traffic_df_cp)
        q_observation = self.observe_q_(self.q)

        Observe from traffic and queue, then compile a summary as information.
        """
        if traffic_df is None:
            raise ValueError("Please feed traffic.")

        # Compile observation
        traffic_observation = self.observe_traffic_(traffic_df)
        q_observation = self.observe_q_(self.q)
        
	# Enqueue traffic
        traffic_df_cp = traffic_df.copy()
        traffic_df_cp['arriveTime_epoch'] = self.epoch
        self.q = self.q.append(traffic_df_cp, ignore_index=True)

        return traffic_observation, q_observation

    def get_service_and_cost(self, control):
        """Generate service based on the control commands
        """

        sleep_flag, control_req = control  # extract control commands
        if sleep_flag:
            service = pd.DataFrame(columns=['sessionID', 'service_per_request_per_domain'])
            cost = 0
        else:
            service = self.serve_requests_(control_req)
            cost = 1
        self.epoch += 1
        return service, cost

    def reset(self):
        self.epoch = 0
        self.q = pd.DataFrame(columns=['sessionID', 'uid', 'arriveTime_epoch', 'bytesSent_per_request_per_domain'])

    # Private Methods
    @staticmethod
    def observe_traffic_(traffic_df):
        """Summary information from current traffic
        Currently the total number of requests and bytes (tuple)
        """
        num_req = 0
        num_bytes = 0
        for idx in traffic_df.index:
            bytesSent_req_domain = json.loads(traffic_df.loc[idx, 'bytesSent_per_request_per_domain'])
            num_req += sum([len(bytesSent_req_domain[domain]) for domain in bytesSent_req_domain])
            num_bytes += sum([bytesSent_req_domain[domain][reqID]
                              for domain in bytesSent_req_domain for reqID in bytesSent_req_domain[domain]])
        return num_req, num_bytes

    @staticmethod
    def observe_q_(q):
        """Summary queue state for observation

        Currently the summary is the # of requests left in to queue
        :return: queue observation
        """
        q_len = 0
        for idx in q.index:
            bytesSent_req_domain = json.loads(q.loc[idx, 'bytesSent_per_request_per_domain'])
            q_len += sum([len(bytesSent_req_domain[domain]) for domain in bytesSent_req_domain])
        return q_len

    def dequeue_all_traffic_(self):
        q = self.q
        self.q = pd.DataFrame(columns=['sessionID', 'uid', 'arriveTime_epoch' 'bytesSent_per_request_per_domain'])
        return q

    def serve_requests_(self, control_req):
        """Serve queued requests.

        :param control_req:
        :return:
        """
        service_df = pd.DataFrame(columns=['sessionID', 'service_per_request_per_domain'])
        drop_indices = []
        num_req_serve = 0
        num_req_queue = 0

        # iterate through q, append to service_df, merge duplicated session ID, update q
        for idx in self.q.index:
            sessionID = int(self.q.loc[idx, 'sessionID'])
            bytesSent_req_domain = json.loads(self.q.loc[idx, 'bytesSent_per_request_per_domain'])
            service_req_domain, bytesSent_req_domain_updated, num_req_serve_row, num_req_queue_row = self.serve_row_(
                control_req=control_req, bytesSent_req_domain=bytesSent_req_domain
            )
            # append to service_df (with dedup)
            service_df = self.append_service_row(service_df=service_df, sessionID=sessionID, service_req_domain=service_req_domain)
            # update queue
            if num_req_queue_row == 0:
                drop_indices.append(idx)
            else:
                self.q.loc[idx, 'bytesSent_req_domain'] = json.dumps(bytesSent_req_domain_updated)
            # update counter
            num_req_serve += num_req_serve_row
            num_req_queue += num_req_queue_row
        self.q.drop(drop_indices, inplace=True)
	if self.verbose > 1:
	    print "**",
	    print "TrafficServer.serve_requests_(): dropped {} q entries".format(len(drop_indices))

        # Verbose message
        if self.verbose > 0:
	    print "*",
            if control_req == 'serve_all':
                print "TrafficServer.serve_requests_(): serving all requests in queue."
            elif control_req == 'queue_all':
                print "TrafficServer.serve_requests_(): queuing all requests in queue."
            elif control_req == 'random_serve_and_queue':
                print "TrafficServer.serve_requests_(): serving {} request and queueing {} requests.".format(
                    num_req_serve, num_req_queue)
            else:
                print "TrafficServer.serve_requests_(): control command not understood, return empty service_df."
        return service_df

    @staticmethod
    def serve_row_(control_req, bytesSent_req_domain):
        service_req_domain = {}
        bytesSent_req_domain_updated = {}
        num_req_serve = 0
        num_req_queue = 0
        for domain in bytesSent_req_domain:  # for each domain in the entry
            for reqID in bytesSent_req_domain[domain]:  # for each request under the domain
                if domain not in service_req_domain:
                    service_req_domain[domain] = {}
                r = np.random.rand()
                if control_req == 'serve_all' or (control_req == 'random_serve_and_queue' and r<0.5):
                    service_req_domain[domain][reqID] = 'serve'
                    num_req_serve += 1
                else:
                    service_req_domain[domain][reqID] = 'queue'
                    num_req_queue += 1
                    # for queued requests, copy to byteSent dict as update
                    if domain not in bytesSent_req_domain_updated:
                        bytesSent_req_domain_updated[domain] = {}
                    bytesSent_req_domain_updated[domain][reqID] = bytesSent_req_domain[domain][reqID]
        return service_req_domain, bytesSent_req_domain_updated, num_req_serve, num_req_queue

    @staticmethod
    def append_service_row(service_df, sessionID, service_req_domain):
        flags = (int(sessionID) == service_df['sessionID'])
        if len(flags.nonzero()[0]) == 0:  # no duplication
            service_df = service_df.append(
                {'sessionID': sessionID, 'service_per_request_per_domain': json.dumps(service_req_domain)},
                ignore_index=True)
        elif len(flags.nonzero()[0]) == 1:  # merge with existing row
            idx_old = flags.nonzero()[0][0]
            service_req_domain_old = json.loads(service_df.loc[idx_old, 'service_per_request_per_domain'])
            for domain in service_req_domain:
                for reqID in service_req_domain[domain]:
                    if domain not in service_req_domain_old:
                        service_req_domain_old[domain] = {}
                    service_req_domain_old[domain][reqID] = service_req_domain[domain][reqID]
            service_df.loc[idx_old, 'service_per_request_per_domain'] = json.dumps(service_req_domain_old)
        else:
            raise ValueError("More than one existing entry found in service_df!")
        return service_df
