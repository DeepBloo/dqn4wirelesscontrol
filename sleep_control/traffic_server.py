import numpy as np
import pandas as pd
import json


class TrafficServer:
    """Emulates the data plane of a communication system

    TrafficServer can provide certain service for the traffic generated by a
    TrafficEmulator. It is essentially the data-plane of a communication
    system, and decide service under the instruction of the control-plane,
    i.e. Controller.

    To use it, first feed it with some traffic and wait it to update its
    internal state, then make observation from it and propagate it to the
    controller, who will issue specific control commands. Using these control
    commands, one can get services for the traffic fed, and also receive a
    operational cost at the same time.

    Note all functions are not necessarily fully controlled by the controller,
    and the TrafficServer may have some sovereign over miscellaneous functions
    and only leave the most important parts for the Controller to decide. To
    this regard, the TrafficServer can have some hidden state that is not
    observable by the controller.

    A important implementation feature in our current project is to give
    TrafficServer the ability to sleep and queue requests. These operational
    states are reflected in both the service generated and the cost emitted.
    """
    def __init__(self, verbose=0, cost=None):
        self.epoch = 0
        self.q = {}
        self.verbose = verbose      # verbosity level
        self.last_traffic_ob = 0
        self.last_q_ob = 0
        self.last_sleep_flag = True
        if cost is None:
            self.OP_COST, self.SW_COST = -1, -0.1
        else:
            self.OP_COST, self.SW_COST = cost

        if verbose>0:
            print " "*4 + "TrafficServer.__init__():",
            print "new TrafficServer with params:"
            print " "*8 + "Op cost: {}, Sw cost: {}".format(self.OP_COST, self.SW_COST)

    # Public Methods
    def observe(self, traffic_df):
        """Compile observation
        traffic_observation = self.observe_traffic_(traffic_df_cp)
        q_observation = self.observe_q_(self.q)

        Observe from traffic and queue, then compile a summary as information.
        """
        if traffic_df is None:
            raise ValueError("Please feed traffic.")

        # Compile observation
        last_traffic_ob = self.last_traffic_ob
        last_q_ob = self.last_q_ob
        new_q_ob = self.observe_q_(self.q)
        self.last_traffic_ob = self.observe_traffic_(traffic_df)
        self.last_q_ob = new_q_ob

        # Enqueue traffic
        traffic_df_cp = traffic_df.copy()
        traffic_df_cp['arriveTime_epoch'] = self.epoch
        if len(traffic_df_cp) > 0:
            self.q[self.epoch] = traffic_df_cp
        return last_q_ob, last_traffic_ob, new_q_ob

    def get_service_and_cost(self, control):
        """Generate service based on the control commands
        """
        sleep_flag, control_req = control  # extract control commands\

        cost = 0
        if sleep_flag:
            service = pd.DataFrame(columns=['sessionID', 'service_per_request_domain'])
        else:
            service = self.serve_requests_(control_req)
            cost += self.OP_COST
        cost += self.SW_COST if self.last_sleep_flag!=sleep_flag else 0

        self.last_sleep_flag = sleep_flag
        self.epoch += 1
        return service, cost

    def reset(self):
        self.epoch = 0
        self.q = {}
        self.last_traffic_ob = 0
        self.last_q_ob = 0
        self.last_sleep_flag = True

    # Private Methods
    @staticmethod
    def observe_traffic_(traffic_df):
        """Summary information from current traffic
        Currently the total number of requests and bytes (tuple)
        """
        num_req = 0
        num_bytes = 0
        for idx in traffic_df.index:
            bytesSent_req_domain = json.loads(traffic_df.get_value(idx, 'bytesSent_per_request_domain'))
            num_req += sum([len(bytesSent_req_domain[domain]) for domain in bytesSent_req_domain])
            num_bytes += sum([bytesSent_req_domain[domain][reqID]
                              for domain in bytesSent_req_domain for reqID in bytesSent_req_domain[domain]])
        return num_req

    @staticmethod
    def observe_q_(q):
        """Summary queue state for observation

        Currently the summary is the # of requests left in to queue
        :return: queue observation
        """
        q_len = 0
        for epoch, df in q.iteritems():
            for idx in df.index:
                bytesSent_req_domain = json.loads(df.get_value(idx, 'bytesSent_per_request_domain'))
                q_len += sum([len(bytesSent_req_domain[domain]) for domain in bytesSent_req_domain])
        return q_len

    def dequeue_all_traffic_(self):
        q = self.q
        self.q = {}
        return q

    def serve_requests_(self, control_req):
        """Serve queued requests.

        :param control_req:
        :return:
        """
        service_df = pd.DataFrame(columns=['sessionID', 'service_per_request_domain'])
        num_req_serve = 0
        num_req_queue = 0
        num_drops = 0

        # iterate through q, append to service_df, merge duplicated session ID, update q
        drop_df_keys = []
        for epoch_key, df in self.q.iteritems():
            drop_indices = []
            for idx in df.index:
                sessionID = int(df.get_value(idx, 'sessionID'))
                bytesSent_req_domain = json.loads(df.get_value(idx, 'bytesSent_per_request_domain'))
                service_req_domain, bytesSent_req_domain_updated, num_req_serve_row, num_req_queue_row = self.serve_row_(
                    control_req=control_req, bytesSent_req_domain=bytesSent_req_domain
                )
                # append to service_df (with dedup)
                service_df = self.append_service_row(service_df=service_df, sessionID=sessionID, service_req_domain=service_req_domain)
                # update queue
                if num_req_queue_row == 0:
                    drop_indices.append(idx)
                else:
                    df.set_value(idx, 'bytesSent_req_domain', json.dumps(bytesSent_req_domain_updated))
                # update counter
                num_req_serve += num_req_serve_row
                num_req_queue += num_req_queue_row
            df.drop(drop_indices, inplace=True)
            num_drops += len(drop_indices)
            drop_df_keys.append(epoch_key) if len(df)==0 else None
        for epoch_key in drop_df_keys:
            del self.q[epoch_key]

        # Verbose message
        if False:
            print " "*8 + "TrafficServer.serve_requests_():",
            if control_req == 'serve_all':
                print "Serving all {} requests in queue.".format(num_req_serve)
            elif control_req == 'queue_all':
                print "Queuing all {} requests in queue.".format(num_req_queue)
            elif control_req == 'random_serve_and_queue':
                print "Serving {} request and queued {} requests.".format(
                    num_req_serve, num_req_queue)
            else:
                print "Control command not understood, return empty service_df."

        if False:
            print " "*8 + "TrafficServer.serve_requests_():",
            print "Dropped {} q entries to deduplicate".format(num_drops)

        return service_df

    @staticmethod
    def serve_row_(control_req, bytesSent_req_domain):
        service_req_domain = {}
        bytesSent_req_domain_updated = {}
        num_req_serve = 0
        num_req_queue = 0
        for domain in bytesSent_req_domain:  # for each domain in the entry
            for reqID in bytesSent_req_domain[domain]:  # for each request under the domain
                if domain not in service_req_domain:
                    service_req_domain[domain] = {}
                r = np.random.rand()
                if control_req == 'serve_all' or (control_req == 'random_serve_and_queue' and r<0.5):
                    service_req_domain[domain][reqID] = 'serve'
                    num_req_serve += 1
                else:
                    service_req_domain[domain][reqID] = 'queue'
                    num_req_queue += 1
                    # for queued requests, copy to byteSent dict as update
                    if domain not in bytesSent_req_domain_updated:
                        bytesSent_req_domain_updated[domain] = {}
                    bytesSent_req_domain_updated[domain][reqID] = bytesSent_req_domain[domain][reqID]
        return service_req_domain, bytesSent_req_domain_updated, num_req_serve, num_req_queue

    @staticmethod
    def append_service_row(service_df, sessionID, service_req_domain):
        flags = (int(sessionID) == service_df['sessionID'])
        if len(flags.nonzero()[0]) == 0:  # no duplication
            service_df = service_df.append(
                {'sessionID': sessionID, 'service_per_request_domain': json.dumps(service_req_domain)},
                ignore_index=True)
        elif len(flags.nonzero()[0]) == 1:  # merge with existing row
            idx_old = flags.nonzero()[0][0]
            service_req_domain_old = json.loads(service_df.get_value(idx_old, 'service_per_request_domain'))
            for domain in service_req_domain:
                for reqID in service_req_domain[domain]:
                    if domain not in service_req_domain_old:
                        service_req_domain_old[domain] = {}
                    service_req_domain_old[domain][reqID] = service_req_domain[domain][reqID]
            service_df.set_value(idx_old, 'service_per_request_domain', json.dumps(service_req_domain_old))
        else:
            raise ValueError("More than one existing entry found in service_df!")
        return service_df
